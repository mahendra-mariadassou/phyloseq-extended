% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fast_unifrac.R
\name{UniFrac}
\alias{UniFrac}
\title{Compute unifrac distances}
\usage{
UniFrac(physeq, weighted = FALSE, normalized = TRUE, parallel = FALSE)
}
\arguments{
\item{physeq}{(Required). \code{\link[phyloseq]{phyloseq-class}}, containing at minimum
a phylogenetic tree (\code{\link[phyloseq]{phylo-class}}) and 
contingency table (\code{\link[phyloseq]{otu_table-class}}). See
examples below for coercions that might be necessary.}

\item{weighted}{(Optional). Logical. Should use weighted-UniFrac calculation?
Weighted-UniFrac takes into account the relative abundance of species/taxa
shared between samples, whereas unweighted-UniFrac only considers 
presence/absence. Default is \code{FALSE}, meaning the unweighted-UniFrac
distance is calculated for all pairs of samples.}

\item{normalized}{(Optional). Logical. Should the output be normalized such that values 
range from 0 to 1 independent of branch length values? Default is \code{TRUE}.
Note that (unweighted) \code{UniFrac} is always normalized by total branch-length,
and so this value is ignored when \code{weighted == FALSE}.}

\item{parallel}{(Optional). Logical. Should execute calculation in parallel,
using multiple CPU cores simultaneously? This can dramatically hasten the
computation time for this function. However, it also requires that the user
has registered a parallel ``backend'' prior to calling this function. 
Default is \code{FALSE}. If FALSE, UniFrac will register a serial backend
so that \code{foreach::\%dopar\%} does not throw a warning.}

\item{...}{Arguments passed from other methods. Used for compatibility purpose.}
}
\value{
A distance matrix
}
\description{
Compute unifrac distances
}
\details{
Support for parallel computations was removed as it proved to
be much lower sequential computations on benchmark data, due to very high overhead.
}
\examples{
data(food)
UniFrac(food)
}
